import "sdi/types.h";
#include <types.idl>

[uuid(IF_MEMORYSERVER_ID)]
interface IF_MEMORYSERVER {
	/**
	  Map special I/O memory to the given virtual address

	  @param threadid Address space Id
	  @param virt_start_address Virtual start address inside the given address space
	  @param phys_start_address Physical start address
	  @param size Mapping size
	  @return 
	*/
	L4_Word_t map_io_pages(in L4_ThreadId_t threadid, in L4_Word_t virt_start_address,
		in L4_Word_t phys_start_address, in int size);

	/**
	  Map anonymous memory to a given address

	  @param threadid Address space Id
	  @param type Memory type
	  @param virt_start_address Virtual start address inside the given address space
	  @param size Mapping size
	  @return
	*/
	L4_Word_t map_anon_pages(in L4_ThreadId_t threadid, in L4_Word_t type,
		in L4_Word_t virt_start_address, in L4_Word_t size);

    // type: use type=0 for now
    // size: size of whole section
    // realsize: size of file content
    // Thus: size >= realsize
	/**
	  Register a file mapping for the given address space

	  @param threadid Address space Id
	  @param type Memory type
	  @param path File path
	  @param offset Start offset inside the file
	  @param virt_start_address Virtual start address inside the given address space
	  @param size Actual size of the file mapping (>= realsize)
	  @param realsize True size of the mapping. The difference between realsize and
		size will be filled up with zeroes
	  @return
	*/
	L4_Word_t map_file_pages(in L4_ThreadId_t threadid, in L4_Word_t type,
		 in path_t path, in L4_Word_t offset, in L4_Word_t virt_start_address,
		 in L4_Word_t size, in L4_Word_t realsize);

	/**
	  Unmap the mapping at the given virtual address

	  @param virt_start_address Virtual start address inside the given address space
	*/
	void unmap_pages(in L4_Word_t virt_start_address);

	/**
	  Send startup IPC to the given thread. L4 demands that the startup IPC must
	  be sent by the pager, and since our task server is separate from the
	  pager, this method is needed.

	  @param threadid Address space Id
	  @param ip Instruction Pointer
	  @param sp Stack pointer. 
	*/
	void startup(in L4_ThreadId_t threadid, in L4_Word_t ip, in L4_Word_t sp);

	/**
	  Will be called by the task server if the given task was destroyed and all
	  mappings can be removed

	  @param threadid Address space Id
	*/
	void destroyed(in L4_ThreadId_t threadid);

	/**
	  Page fault handler

	  @param address Address space Id
	  @param ip Faulting instruction pointer
	  @param privileges Fault reason (r = read, w = write, x = execute)
	  @param page Returned Fpage
	*/
	[kernelmsg(idl4::pagefault)]
	void pagefault(in L4_Word_t address, in L4_Word_t ip, in L4_Word_t privileges,
		out fpage page);
};


import "sdi/types.h";
#include <types.idl>

#include <ifnaming.idl>
#include <iffile.idl>

[uuid(IF_TASKSERVER_ID)]
interface IF_TASKSERVER : IF_NAMING, IF_FILE {
    /**
      Start the binary at the given path as a new task

      @param path Binary path
      @param cmdline Command line
      @return L4_nilthread on error, task id on success
    */
    L4_ThreadId_t create_task(in path_t path, in path_t cmdline);

    /**
      Create a new thread inside the address space of the caller
        
      @param ip Instruction Pointer
      @param sp Stack Pointer
      @return Thread Id
    */
    L4_ThreadId_t create_thread(in L4_Word_t ip, in L4_Word_t sp);
        
    /**
      Kill the given task

      @param task_id Task Id
    */
    void kill_task(in L4_ThreadId_t task_id);

    /**
      Kill the given thread

      @param thread_id Thread Id
    */
    void kill_thread(in L4_ThreadId_t thread_id);
    
    /**
      Set the priority of the given thread

      @param thread_id Thread id
      @param prio New priority
    */
    void set_priority(in L4_ThreadId_t thread_id, in L4_Word_t prio);

    /**
      Called by other servers if the given thread id generated a non-
      recoverable fault

      @param thread_id Thread id
    */
    void destroyed(in L4_ThreadId_t thread_id);

    /**
      Register the calling thread as the handler for the given hardware
       interrupt

      @param int_num Interrupt number   
    */
    void attach_interrupt(in L4_Word_t int_num);
	
	/**
      Checks, if a taks with given number is available and therefore running

      @param task_id ID of Task that is checked for his state
      @return Returns true, if task is created and running
    */
    boolean is_running(in L4_ThreadId_t task_id);

};


/*****************************************************************
 * Source file : driverserver.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 16/07/2012 02:31
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include <idl4glue.h>
#include "driverserver-server.h"
#include <l4/types.h>
#include <l4io.h>
#include <sdi/sdi.h>
#include <sdi/constants.h>
#include <stdlib.h>

#include <if/iflogging.h>

#include <nameserver.h>

/* Interface IF_NAMESERVER */

typedef struct {
        char path[SDI_NAMESERVER_MAX_ENTRY_LEN + 1];
        L4_ThreadId_t registrant;
} name_entry_t;

name_entry_t drivers[SDI_NAMESERVER_MAX_ENTRIES];

L4_ThreadId_t loggerid;
CORBA_Environment env(idl4_default_environment);



/* Interface driverserver */
/**
   Find the next free name database entry

   @return index on success, -1 if database full
 */
int find_free_entry()
{
        for (int i = 0; i < SDI_NAMESERVER_MAX_ENTRIES; i++)
                if (drivers[i].registrant == L4_nilthread)
                        return i;

        return -1;
}

IDL4_INLINE void  driverserver_register_implementation(CORBA_Object  _caller, const path_t  path, idl4_server_environment * _env)

{
        int i = find_free_entry();

        if (i >= 0) {
                strncpy(drivers[i].path, path, SDI_NAMESERVER_MAX_ENTRY_LEN);
                drivers[i].registrant = _caller;
        }else
                printf("[NAMESERVER] Error: Could not register thread %lx for path \"%s\", database full\n", _caller.raw, path);

        return;
}

IDL4_PUBLISH_DRIVERSERVER_REGISTER(driverserver_register_implementation);

IDL4_INLINE void  driverserver_deregister_implementation(CORBA_Object  _caller, idl4_server_environment * _env)

{
        /* Remove all entries for the caller thread */
        for (int i = 0; i < SDI_NAMESERVER_MAX_ENTRIES; i++)
                if (drivers[i].registrant == _caller) {
                        drivers[i].registrant = L4_nilthread;
                        drivers[i].path[0] = '\0';
                }

        return;
}

IDL4_PUBLISH_DRIVERSERVER_DEREGISTER(driverserver_deregister_implementation);

IDL4_INLINE L4_ThreadId_t  driverserver_Lookup_implementation(CORBA_Object  _caller, const path_t  path, path_t * remaining, idl4_server_environment * _env)

{
	int offset = 0;

	if(path[0] == '/')
		offset = 1;

        /* Find the first database entry matching the query */
        for (int i = 0; i < SDI_NAMESERVER_MAX_ENTRIES; i++)
                if (strncmp(path, drivers[i].path, strlen(drivers[i].path)) == 0) {
                        strcpy(*remaining, &path[strlen(drivers[i].path) + offset]);
                        return drivers[i].registrant;
                }

        strcpy(*remaining, path);
        return L4_nilthread;


}

IDL4_PUBLISH_DRIVERSERVER_LOOKUP(driverserver_Lookup_implementation);

void * driverserver_vtable_4[DRIVERSERVER_DEFAULT_VTABLE_SIZE] = DRIVERSERVER_DEFAULT_VTABLE_4;
void * driverserver_vtable_8[DRIVERSERVER_DEFAULT_VTABLE_SIZE] = DRIVERSERVER_DEFAULT_VTABLE_8;
void * driverserver_vtable_discard[DRIVERSERVER_DEFAULT_VTABLE_SIZE] = DRIVERSERVER_DEFAULT_VTABLE_DISCARD;
void ** driverserver_itable[16] = { driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_4, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_8, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard, driverserver_vtable_discard };

void  driverserver_server(void)

{
  L4_ThreadId_t  partner;
  L4_MsgTag_t  msgtag;
  idl4_msgbuf_t  msgbuf;
  long  cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < DRIVERSERVER_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, driverserver_itable[idl4_get_interface_id(&msgtag) & DRIVERSERVER_IID_MASK][idl4_get_function_id(&msgtag) & DRIVERSERVER_FID_MASK]);
        }
    }
}

void  driverserver_discard(void)

{
}

void clear_name_database()
{
        for (int i = 0; i < SDI_NAMESERVER_MAX_ENTRIES; i++) {
                drivers[i].path[0] = '\0';
                drivers[i].registrant = L4_nilthread;
        }
}


int main(void)
{
        clear_name_database();

        CORBA_Environment env(idl4_default_environment);

        L4_ThreadId_t loggerid = L4_nilthread;

        while (L4_IsNilThread(loggerid))
                loggerid = nameserver_lookup("/server/logger");

        IF_LOGGING_LogMessage((CORBA_Object)loggerid, "[DRIVERSERVER] Registering", &env);

	nameserver_register("/driver");

        IF_LOGGING_LogMessage((CORBA_Object)loggerid, "[DRIVERSERVER] Registered...", &env);

        driverserver_server();
}



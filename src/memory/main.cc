/*****************************************************************
 * Source file : memory.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 10/07/2012 14:36
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include <l4io.h>
#include <idl4glue.h>
#include "memory-server.h"
#include <l4/types.h>
#include <sdi/sdi.h>
#include <sdi/types.h>
#include <macros.h>
#include <l4/kdebug.h>

/* Interface memory */

IDL4_INLINE void  memory_map_io_pages_implementation(CORBA_Object  _caller, const CORBA_long  threadid, const CORBA_long  virt_start_address, const CORBA_long  phys_start_address, const CORBA_long  size, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::map_io_pages */
  
  return;
}

IDL4_PUBLISH_MEMORY_MAP_IO_PAGES(memory_map_io_pages_implementation);

IDL4_INLINE void  memory_map_anon_pages_implementation(CORBA_Object  _caller, const CORBA_long  threadid, const CORBA_long  type, const CORBA_long  virt_start_address, const CORBA_long  num_pages, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::map_anon_pages */
  
  return;
}

IDL4_PUBLISH_MEMORY_MAP_ANON_PAGES(memory_map_anon_pages_implementation);

IDL4_INLINE void  memory_map_file_pages_implementation(CORBA_Object  _caller, const CORBA_long  threadid, const CORBA_long  type, const CORBA_char * path, const CORBA_long  offset, const CORBA_long  virt_start_address, const CORBA_long  size, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::map_file_pages */
  
  return;
}

IDL4_PUBLISH_MEMORY_MAP_FILE_PAGES(memory_map_file_pages_implementation);

IDL4_INLINE void  memory_unmap_pages_implementation(CORBA_Object  _caller, const CORBA_long  virt_start_address, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::unmap_pages */
  
  return;
}

IDL4_PUBLISH_MEMORY_UNMAP_PAGES(memory_unmap_pages_implementation);

IDL4_INLINE void  memory_startup_implementation(CORBA_Object  _caller, const CORBA_long  threadid, const CORBA_long  ip, const CORBA_long  sp, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::startup */
  
  return;
}

IDL4_PUBLISH_MEMORY_STARTUP(memory_startup_implementation);

IDL4_INLINE void  memory_destroy_implementation(CORBA_Object  _caller, const CORBA_long  threadid, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::destroy */
  
  return;
}

IDL4_PUBLISH_MEMORY_DESTROY(memory_destroy_implementation);

IDL4_INLINE void  memory_pagefault_implementation(CORBA_Object  _caller, const CORBA_long  addr, const CORBA_long  ip, idl4_fpage_t * f, idl4_server_environment * _env)

{
  /* implementation of IF_MEMORY::pagefault */
  
  return;
}

IDL4_PUBLISH_MEMORY_PAGEFAULT(memory_pagefault_implementation);

void * memory_vtable_4[MEMORY_DEFAULT_VTABLE_SIZE] = MEMORY_DEFAULT_VTABLE_4;
void * memory_vtable_discard[MEMORY_DEFAULT_VTABLE_SIZE] = MEMORY_DEFAULT_VTABLE_DISCARD;
void ** memory_itable[8] = { memory_vtable_discard, memory_vtable_discard, memory_vtable_discard, memory_vtable_discard, memory_vtable_4, memory_vtable_discard, memory_vtable_discard, memory_vtable_discard };

void  memory_server(void)

{
  L4_ThreadId_t  partner;
  L4_MsgTag_t  msgtag;
  idl4_msgbuf_t  msgbuf;
  long  cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < MEMORY_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, memory_itable[idl4_get_interface_id(&msgtag) & MEMORY_IID_MASK][idl4_get_function_id(&msgtag) & MEMORY_FID_MASK]);
        }
    }
}

void  memory_discard(void)

{
}

int main(void){

    L4_Word_t faddr = 0;

    for(int i=0; i<0xFFFF; i = i + 0x1000)
    {
      volatile char* dummy = (char *)faddr;
      *dummy;
      faddr = faddr + i;
    }
    printf("Fetched memory.");
    memory_server();
    return 0;
}


/*****************************************************************
 * Source file : /home/stoess/devel/sdios.new/src/root/locator.idl
 * Platform    : V4 Generic
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 15/05/2009 23:28
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include <idl4glue.h>
#include "locator-server.h"
#include <l4/types.h>
#include <l4io.h>
#include <sdi/sdi.h>

L4_ThreadId_t services[MAX_INTERFACEID];

void init_locator (void) {
    for (int i=0; i<MAX_INTERFACEID;i++)
	services[i] = L4_nilthread;
    services[IF_LOCATOR_ID] = L4_Myself ();
}


/* Interface locator */

IDL4_INLINE void  locator_Announce_implementation(CORBA_Object  _caller, const interfaceid_t  type, const L4_ThreadId_t * thread, idl4_server_environment * _env)

{
    /* implementation of IF_LOCATOR::Announce */
    if (L4_IsNilThread (services[type % MAX_INTERFACEID])) {
	services[type % MAX_INTERFACEID] = *thread;
    } else {
	CORBA_exception_set (_env, ex_type_conflict, 0);
    }
    return;
}

IDL4_PUBLISH_LOCATOR_ANNOUNCE(locator_Announce_implementation);

IDL4_INLINE void  locator_Locate_implementation(CORBA_Object  _caller, const interfaceid_t  type, L4_ThreadId_t * thread, idl4_server_environment * _env)
{
    /* implementation of IF_LOCATOR::Locate */
    *thread = services[type % MAX_INTERFACEID];
    return;
}

IDL4_PUBLISH_LOCATOR_LOCATE(locator_Locate_implementation);

void * locator_vtable_2[LOCATOR_DEFAULT_VTABLE_SIZE] = LOCATOR_DEFAULT_VTABLE_2;
void * locator_vtable_discard[LOCATOR_DEFAULT_VTABLE_SIZE] = LOCATOR_DEFAULT_VTABLE_DISCARD;
void ** locator_itable[4] = { locator_vtable_discard, locator_vtable_discard, locator_vtable_2, locator_vtable_discard };

void  locator_server()

{
  L4_ThreadId_t  partner;
  L4_MsgTag_t  msgtag;
  idl4_msgbuf_t  msgbuf;
  long  cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < LOCATOR_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, locator_itable[idl4_get_interface_id(&msgtag) & LOCATOR_IID_MASK][idl4_get_function_id(&msgtag) & LOCATOR_FID_MASK]);
        }
    }
}

void  locator_discard()

{
}


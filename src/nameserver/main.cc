/*****************************************************************
 * Source file : ../../if/ifnameserver.idl
 * Platform    : V4 Generic
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 09/07/2012 14:58
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include "main_server.h"

/* Interface IF_NAMESERVER */

IDL4_INLINE void  IF_NAMESERVER_register_implementation(CORBA_Object  _caller, const path_t  path, idl4_server_environment * _env)

{
  /* implementation of IF_NAMESERVER::register */
  
  return;
}

IDL4_PUBLISH_IF_NAMESERVER_REGISTER(IF_NAMESERVER_register_implementation);

IDL4_INLINE void  IF_NAMESERVER_unregister_implementation(CORBA_Object  _caller, const path_t  path, idl4_server_environment * _env)

{
  /* implementation of IF_NAMESERVER::unregister */
  
  return;
}

IDL4_PUBLISH_IF_NAMESERVER_UNREGISTER(IF_NAMESERVER_unregister_implementation);

IDL4_INLINE void  IF_NAMESERVER_Lookup_implementation(CORBA_Object  _caller, const path_t  path, path_t * remaining, idl4_server_environment * _env)

{
  /* implementation of IF_NAMING::Lookup */
  
  return;
}

IDL4_PUBLISH_IF_NAMESERVER_LOOKUP(IF_NAMESERVER_Lookup_implementation);

void * IF_NAMESERVER_vtable_4[IF_NAMESERVER_DEFAULT_VTABLE_SIZE] = IF_NAMESERVER_DEFAULT_VTABLE_4;
void * IF_NAMESERVER_vtable_5[IF_NAMESERVER_DEFAULT_VTABLE_SIZE] = IF_NAMESERVER_DEFAULT_VTABLE_5;
void * IF_NAMESERVER_vtable_discard[IF_NAMESERVER_DEFAULT_VTABLE_SIZE] = IF_NAMESERVER_DEFAULT_VTABLE_DISCARD;
void ** IF_NAMESERVER_itable[8] = { IF_NAMESERVER_vtable_discard, IF_NAMESERVER_vtable_discard, IF_NAMESERVER_vtable_discard, IF_NAMESERVER_vtable_discard, IF_NAMESERVER_vtable_4, IF_NAMESERVER_vtable_5, IF_NAMESERVER_vtable_discard, IF_NAMESERVER_vtable_discard };

void  IF_NAMESERVER_server()

{
  L4_ThreadId_t  partner;
  L4_MsgTag_t  msgtag;
  idl4_msgbuf_t  msgbuf;
  long  cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < IF_NAMESERVER_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, IF_NAMESERVER_itable[idl4_get_interface_id(&msgtag) & IF_NAMESERVER_IID_MASK][idl4_get_function_id(&msgtag) & IF_NAMESERVER_FID_MASK]);
        }
    }
}

void  IF_NAMESERVER_discard()

{
}

